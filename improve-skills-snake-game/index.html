<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Mejora las skills de programación creando un juego de snake en C#</title>
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
      <link rel="stylesheet" href="../style.css">
      <link rel="stylesheet" href="./style.css">      
  </head>
  <body class="body-background">

    <nav class="navbar navbar-light fixed-top nav-background">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">
          <img src="../images/logo.jpg" alt="" width="35" height="35" class="rounded-circle d-inline-block">
          <span class="ms-2">
            David Restrepo
          </span>
        </a>
      </div>
    </nav>
      
    <main class="container">

      <div class="row">

        <div class="col-12 col-md-9">
          
          <div id="doc-wrapper">
            <div id="doc-content">
              <!-- DOC -->

<div class="c11 doc-content rounded"><p class="c10 title" id="h.qee7wye4bd1l"><span class="c2 c7">Mejora las skills de programaci&oacute;n creando un juego de snake en C#</span></p><p class="c12"><span class="c5">Marzo 30, 2025</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">&iquest;Quieres mejorar tu l&oacute;gica de programaci&oacute;n sin depender de frameworks? He notado que a muchos de mis colegas se les dificulta llevar a cabo sus desarrollos si no &nbsp;existe una librer&iacute;a(Nuget, Plugin, Componente, Etc&hellip;) que haga exactamente lo que se espera como resultado final y es algo que en ocasiones resulta frustrante. Pero que no se confunda mi opini&oacute;n, las librer&iacute;as y componentes externos son necesarios, pero muchas veces, un desarrollo que puede ser sencillo se complica por el af&aacute;n de ahorrar trabajo y esfuerzo.</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">Por eso quiero mostrar que con conceptos b&aacute;sicos que todos los programadores conocemos se pueden lograr resultados sorprendentes. Haciendo uso de una matriz (o array bidimensional) vamos a crear un juego de snake, desde el motor del juego hasta la parte que renderiza la imagen que se muestra en pantalla y tambi&eacute;n a&ntilde;adiremos sonidos. </span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 313.11px; height: 330.50px;"><img alt="" src="images/image4.png" style="width: 313.11px; height: 330.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">Este ejemplo lo realizaremos en C# de .Net y solo utilizaremos librer&iacute;as del propio .Net.</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span>Vamos a hacer uso de una matriz como componente principal para darle vida a nuestro snake</span><span class="c5">. </span><span>Cada elemento de la matriz tiene un n&uacute;mero al que est&aacute; asociado, llamado &quot;&iacute;ndice&quot;, que permite acceder a &eacute;l.</span></p><p class="c0 c4"><span class="c3 c5"></span></p><p class="c0"><span class="c2">F&aacute;cilmente podemos comparar la representaci&oacute;n </span><span>gr&aacute;fica</span><span class="c2">&nbsp;de una matriz con un tablero de ajedrez; supongamos que tenemos una pe&oacute;n en la posici&oacute;n(</span><span>&iacute;ndice</span><span class="c2">) [2, 2] y queremos que este se </span><span>mueva</span><span class="c2">&nbsp;una casilla a nuestra izquierda. </span><span>P</span><span class="c2">odemos observar que para simular este movimiento a la izquierda la nueva posici&oacute;n de nuestro pe&oacute;n </span><span>ser&iacute;a</span><span class="c2">&nbsp;[2, 1], por lo tanto, podemos asumir que los movimientos a la izquierda restan y los movimientos a la derecha suman, igual que en la recta num&eacute;rica, y, del mismo modo para los movimientos hacia arriba y hacia abajo. Aunque la comparaci&oacute;n con el tablero de ajedrez es un buen ejemplo, debemos ponernos </span><span>m&aacute;s</span><span class="c3 c2">&nbsp;t&eacute;cnicos para poder comprender la idea general.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 409.07px; height: 336.13px;"><img alt="" src="images/image1.png" style="width: 409.07px; height: 336.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c2">Una comparaci&oacute;n </span><span>m&aacute;s</span><span class="c2">&nbsp;acertada de nuestra matriz o de nuestro tablero de ajedrez </span><span>ser&iacute;a</span><span class="c3 c2">&nbsp;con el cuarto cuadrante del plano cartesiano:</span></p><p class="c0"><span class="c2">Una vez en el plano cartesiano, sabemos que para ubicar un punto debemos usar las variables </span><span class="c5">x</span><span class="c2">&nbsp;y </span><span class="c5">y</span><span class="c2">, que a su vez, ser&aacute;n el </span><span>&iacute;ndice</span><span class="c3 c2">&nbsp;de nuestra matriz:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.00px; height: 341.00px;"><img alt="" src="images/image5.png" style="width: 337.00px; height: 341.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2">La gran diferencia entre el plano cartesiano y una matriz, es que en la matriz podemos almacenar diferentes valores en cada uno de los </span><span>&iacute;ndices</span><span class="c2">&nbsp;o posiciones, por ejemplo tenemos los siguientes valores almacenados en los </span><span>&iacute;ndices</span><span class="c3 c2">&nbsp;dados:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 350.00px; height: 392.00px;"><img alt="" src="images/image3.png" style="width: 350.00px; height: 392.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c4"><span class="c3 c2"></span></p><ol class="c8 lst-kix_list_1-0 start" start="1"><li class="c0 c1 li-bullet-0"><span class="c3 c2">[4, 3] = 2</span></li><li class="c0 c1 li-bullet-0"><span class="c3 c2">[0, 2] = 1</span></li><li class="c0 c1 li-bullet-0"><span class="c3 c2">[0, 3] = 1</span></li><li class="c0 c1 li-bullet-0"><span class="c3 c2">[2, 1] = 0</span></li></ol><p class="c0 c4 c6"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">se pueden representar en el plano cartesiano/matriz de la siguiente manera:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.00px; height: 387.00px;"><img alt="" src="images/image2.png" style="width: 358.00px; height: 387.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2">Ahora, volviendo al ejemplo inicial, si queremos que el </span><span>n&uacute;mero</span><span class="c2">&nbsp;&ldquo;2&rdquo; se mueva hacia la izquierda podr&iacute;amos utilizar la siguiente </span><span>f&oacute;rmula</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">matriz[posision_x - 1, posision_y] = 2</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">En nuestro caso concreto quedar&iacute;a de esta manera:</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">matriz[3 - 1, 4] = 2</span></p><p class="c0"><span class="c3 c2">matriz[2, 4] = 2</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c2">Vemos que el nuevo </span><span>&iacute;ndice</span><span class="c2">&nbsp;o posici&oacute;n para el </span><span>n&uacute;mero</span><span class="c2">&nbsp;2 es [2, 4]. Lo que representar&iacute;a un movimiento a la izquierda en comparaci&oacute;n a la posici&oacute;n original: [3, 4], y esto mismo aplicar&iacute;a para las cuatro direcciones tal cual se </span><span>describe</span><span class="c3 c2">&nbsp;en el ejemplo inicial:</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c3 c2">Movimiento a la izquierda:</span></p><p class="c0"><span class="c3 c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matriz[posision_x - 1, posision_y] </span></p><p class="c0"><span class="c3 c2">Movimiento a la derecha</span></p><p class="c0"><span class="c3 c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matriz[posision_x + 1, posision_y] </span></p><p class="c0"><span class="c2 c3">Movimiento hacia arriba</span></p><p class="c0"><span class="c3 c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matriz[posision_x, posision_y &ndash; 1]</span></p><p class="c0"><span class="c3 c2">Movimiento hacia abajo</span></p><p class="c0"><span class="c3 c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matriz[posision_x, posision_y + 1] &nbsp;</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c2">Esto en principio </span><span>ser&aacute;</span><span class="c2">&nbsp;el concepto base de nuestro juego de snake, ahora es hora de pasar al gameplay. Todos conocemos la mec&aacute;nica del juego de snake: se controla la direcci&oacute;n de una serpiente que avanza autom&aacute;ticamente; al iniciar el juego la longitud de esta serpiente es m&iacute;nima y para aumentar dicha longitud se debe hacer pasar la cabeza de la serpiente sobre un punto que se genera en una posici&oacute;n aleatoria del mapa del juego. Una vez aumenta la longitud de la serpiente aumenta la </span><span>dificultad</span><span class="c2">&nbsp;debido a que debemos evitar que la cabeza colisione con el cuerpo de la misma serpiente o con los bordes del mapa. De ocurrir cualquiera de estas dos situaciones </span><span>ser&iacute;a</span><span class="c3 c2">&nbsp;el fin del juego.</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c2">Adicional al gameplay, tambi&eacute;n debemos pensar en </span><span>c&oacute;mo</span><span class="c2">&nbsp;vamos a </span><span>renderizar</span><span class="c2">&nbsp;los gr&aacute;ficos de nuestro juego. Esto a primera vista puede parecer algo un tanto complicado, pero debemos recordar que una imagen es una colecci&oacute;n de pixeles que est&aacute;n organizados en una matriz y la base de nuestro juego es una matriz!, teniendo esto en cuenta lo &uacute;nico que debemos hacer para &ldquo;renderizar&rdquo; nuestro juego es hacer una copia de la matriz en una imagen. En C# </span><span>podemos</span><span class="c2">&nbsp;utilizar la librer&iacute;a System.Drawing.Bitmap que nos permite especificar el color de un pixel en un </span><span>&iacute;ndice</span><span class="c3 c2">&nbsp;dado.</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c2">Hay que tener en cuenta que un </span><span>&iacute;ndice</span><span class="c2">&nbsp;de nuestra matriz equivale a un </span><span>p&iacute;xel</span><span class="c2">&nbsp;de la imagen, por lo que no podr&iacute;amos distinguir la serpiente en la pantalla. Debemos usar una escala al renderizar la imagen, ejemplo: si usamos una escala de 10, cada </span><span>&iacute;ndice</span><span class="c2">&nbsp;de nuestra matriz </span><span>equivaldr&iacute;a</span><span class="c2">&nbsp;a 10 </span><span>p&iacute;xeles</span><span class="c3 c2">&nbsp;de la imagen que vamos a mostrar en pantalla.</span></p><p class="c0 c4"><span class="c3 c2"></span></p><p class="c0"><span class="c2">Otro aspecto importante que debemos tener en cuenta es el tiempo. Debemos determinar </span><span>cu&aacute;ntos</span><span class="c2">&nbsp;frames por segundo va tener nuestro juego, o mejor dicho, cada </span><span>cu&aacute;nto</span><span class="c2">&nbsp;vamos a ejecutar las validaciones y las acciones del snake. El intervalo entre un frame y otro lo vamos a conocer como delta time y lo vamos a definir en milisegundos. En cada uno de estos intervalos vamos a hacer avanzar la serpiente un paso a la vez, pero no sin antes verificar que en ese paso siguiente no </span><span>vaya</span><span class="c2">&nbsp;a colisionar con los bordes del mapa o con su propio cuerpo y del mismo modo </span><span>valoraremos</span><span class="c2">&nbsp;si </span><span>ha &ldquo;comido&rdquo;</span><span class="c2">&nbsp;un punto para aumentar la longitud.</span></p></div>

              <!-- DOC -->
            </div>
          </div>

        </div>

        <div class="col-12 col-md-3">
          
          <aside id="sidebar">

            <h3>Otros artículos</h3>
            
            <div class="card">
              <img src="../images/cloud-efficiency -load-model-banner.png" class="card-img-top" alt="...">
              <div class="card-body">
                <h4 class="card-title">
                  <a href="../cloud-efficiency -load-model/index.html" class="text-dark">Modelo de Carga Eficiente en la Nube</a>
                </h4>
                <p class="card-text">Este es un modelo matemático que ayuda a determinar cuál es la cantidad óptima de instancias o servidores.</p>
                <a href="../cloud-efficiency -load-model/index.html" class="btn btn-primary mt-3">Ir al artículo</a>
              </div>
            </div>

          </aside>

        </div>
        
      </div>

    </main>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  </body>
</html>